(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{437:function(t,_,v){"use strict";v.r(_);var a=v(54),s=Object(a.a)({},(function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"http"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http"}},[t._v("#")]),t._v(" HTTP")]),t._v(" "),v("h2",{attrs:{id:"http历史"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http历史"}},[t._v("#")]),t._v(" HTTP历史")]),t._v(" "),v("h3",{attrs:{id:"_1-0"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-0"}},[t._v("#")]),t._v(" 1.0")]),t._v(" "),v("p",[t._v("浏览器每次请求都需要和服务器建立一次TCP连接，服务器完成请求处理后立即断开TCP连接，")]),t._v(" "),v("p",[t._v("缺点：连接无法复用、只有前面的请求返回之后才能进行下一次请求，HTTP头阻塞（服务器必须按照请求的顺序来响应，后续请求的响应必须等前面的响应结束了才能发送）；每个域名绑定一个唯一的IP地址；存在浪费带宽的现象")]),t._v(" "),v("p",[v("strong",[t._v("解决HTTP头阻塞")]),t._v("：1、并发连接，一个客户端可以和一个域名的服务器并发多个连接 2、域名分片 3、使用HTTP2.0（前面几种都是为了增加一个客户端和服务端的TCP连接）")]),t._v(" "),v("h3",{attrs:{id:"_1-1"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-1"}},[t._v("#")]),t._v(" 1.1")]),t._v(" "),v("p",[t._v("支持持久连接，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。在一个连接中，允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，是串行化地传送，但是服务端必须按照接收客户端请求的先后顺序依次回送响应结果； 为了解决头阻塞问题，利用"),v("strong",[t._v("管线化")]),t._v("的技术")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("缓存：1.0主要使用header里面的if-modified-since、expires作为缓存判断，1.1则引入了如etag、if-match、if-none-match等更多缓存头来控制缓存策略")])]),t._v(" "),v("li",[v("p",[t._v("带宽优化：1.0只能支持整个对象从0传送，1.1加入range请求头部字段，如果能处理则返回码是206，这样方便开发者自由选择")])]),t._v(" "),v("li",[v("p",[t._v("Host头处理：扩展了http1.0，http1.0认定每台服务器就绑定一个唯一的ip地址，1.1增加了更多了请求头和响应头，如host请求头字段，可以实现一台服务器（一个ip地址下）下可以配置多个虚拟web站点，虚拟主机技术")])]),t._v(" "),v("li",[v("p",[t._v("长连接：Connection请求头的值为Keep-Alive时，客户端通知服务器返回本次请求结果后保持连接；Connection请求头的值为close时，客户端通知服务器返回本次请求结果后关闭连接")]),t._v(" "),v("p",[t._v("http1.1的问题： 建立多个TCP、TCP的慢启动、")])])]),t._v(" "),v("h3",{attrs:{id:"_2-0"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-0"}},[t._v("#")]),t._v(" 2.0")]),t._v(" "),v("p",[t._v("主要基于"),v("strong",[t._v("SPDY协议")]),t._v("，大幅度提高web性能，体现在头部压缩、多路复用、二进制分帧，服务器推送")]),t._v(" "),v("p",[t._v("头部压缩：针对头部字段进行压缩")]),t._v(" "),v("p",[t._v("多路复用：HTTP/2 用"),v("strong",[t._v("流")]),t._v("来在一个 TCP 连接上来进行多个数据帧的通信，这就是"),v("strong",[t._v("多路复用")]),t._v("的概念。解决HTTP头阻塞的问题，基于二进制分帧层，可以在共享TCP连接的基础上同时发送请求和响应")]),t._v(" "),v("p",[t._v("二进制分帧：不是采用1.x的文本格式，而是将报文全部拆分为一个个二进制的帧，二进制帧不存在先后关系，也不会排队等待了。通信双方都可以给对方发送二进制帧，这种二进制帧的双向传输序列也被称为"),v("strong",[t._v("流")]),t._v("。多个请求在一次连接中并行执行，一次连接中能发送不同流的数据。")]),t._v(" "),v("p",[t._v("服务器推送")]),t._v(" "),v("p",[t._v("但还是没法解决TCP头阻塞问题，建立在一个TCP连接之上，如果TCP遇到丢包的问题，也会造成阻塞")]),t._v(" "),v("h3",{attrs:{id:"_3-0"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-0"}},[t._v("#")]),t._v(" 3.0")]),t._v(" "),v("p",[t._v("基于UDP，取了TCP中的精华。基于QUIC协议，在UDP基础之上，实现了TCP中的流量控制、拥塞控制、并且实现快速握手、TLS安全加密等。")]),t._v(" "),v("h2",{attrs:{id:"https"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#https"}},[t._v("#")]),t._v(" HTTPS")]),t._v(" "),v("h3",{attrs:{id:"http缺点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http缺点"}},[t._v("#")]),t._v(" http缺点：")]),t._v(" "),v("p",[t._v("1、http是使用明文传输，不加密，内容可能被监听")]),t._v(" "),v("p",[t._v("通信的加密：SSL（安全套接层）、TSL（安全层传输协议）")]),t._v(" "),v("p",[t._v("内容的加密：把HTTP报文里所含的内容进行加密处理，客户端和服务器同时具备加密和解密的机制。")]),t._v(" "),v("p",[t._v("用SSL建立安全通信线路之后，就可以在这条线路上进行HTTP通信了。与SSL组合使用的HTTP被称为HTTPS，超文本传输安全协议")]),t._v(" "),v("p",[t._v("2、不验证通信方的身份，可能遭遇为伪装；无法确认是不是连着真正指定的主机，返回的响应是不是就是指定服务器返回的")]),t._v(" "),v("p",[t._v("使用HTTP协议无法确定通信方，但是使用SSL可以，SSL提供加密，还使用了一种称为证书的手段")]),t._v(" "),v("p",[t._v("证书：权威第三方颁发，用以证明服务器和客户端是实际存在的")]),t._v(" "),v("p",[t._v("3、无法确保报文的完整性，通信途中可能遭到篡改")]),t._v(" "),v("p",[t._v("如何防止？最常用的是MD5和SHA-1登散列值校验的方法，用来确认文件的数字签名方法")]),t._v(" "),v("p",[t._v("HTTP+"),v("strong",[t._v("加密+认证+完整性保护 = HTTPS")]),t._v("，在应用层HTTP和传输层TCP之间加了一层SSL，SSL之后被更名为TLS")]),t._v(" "),v("p",[t._v("SSL采用了一种叫做公开密钥加密的加密处理方式")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("对称密钥加密：客户端和服务器"),v("strong",[t._v("加密和解密使用相同的密钥")]),t._v("；但如果这密钥被攻击方监听到，就失去了加密的意义")])]),t._v(" "),v("li",[v("p",[t._v("使用两把密钥的公开密钥加密，非对称的密钥加密。发送密文的一方使用对方的公钥进行加密处理，收到加密信息后，用自己的私钥解密。但处理报文解密会很慢")])]),t._v(" "),v("li",[v("p",[t._v("HTTPS采用混合加密机制（TLS采用）：使用非对称加密的方式加密共享的密钥，就只用私钥解密那个用来通信的公开密钥就行。如果安全，就用公开密钥加密后进行通信。服务端要发送公钥给客户端通信，而这个"),v("strong",[t._v("公钥")]),t._v("要进行数字签名。服务端发送公钥、有一把私钥解密；服务端用植入到浏览器的数字证书认证机构的公钥验证服务端发送的公钥、用该公钥进行加密。")]),t._v(" "),v("p",[t._v("简单说：公钥加密会话密钥，私钥解密后就拿到会话密钥，双方就实现了对称密钥的安全交换")])]),t._v(" "),v("li",[v("p",[t._v("HTTPS的完整性（采用摘要算法）：用特定算法对内容进行生成hash值摘要，客户端用服务端的公钥对摘要和内容进行加密，服务端拿到后用相同算法对内容进行算法分析，看生成的hash值是否一致。")])])]),t._v(" "),v("p",[t._v("加密和解密的公开密钥如何证明有效？这就使用到数字证书认证机构CA。数字证书认证机构会对"),v("strong",[t._v("公开密钥")]),t._v("进行"),v("strong",[t._v("数字签名")]),t._v("，然后分配这个已签名的公开密钥。")]),t._v(" "),v("details",{staticClass:"custom-block details"},[v("summary",[t._v("DETAILS")]),t._v(" "),v("p",[t._v("Q：什么是数字签名？")]),t._v(" "),v("p",[t._v("A：发送端对内容进行hash算法加密生成摘要，并用自己的私钥对摘要进行加密，生成的叫数字签名。接收端用公钥对数字签名进行解密，如果能解密，则证明确实是该发送端发过来的。再用内容本身用同样的hash算法进行加密，两者一样，验证完整性")]),t._v(" "),v("p",[t._v("Q：什么是数字证书？")]),t._v(" "),v("p",[t._v("A：数字证书用于确保接收端用的"),v("strong",[t._v("服务端公钥")]),t._v("是正确的。权威机构给服务端公钥进行加密，然后将自己解密的私钥植入到浏览器，可以进行解密验证公钥。")]),t._v(" "),v("p",[t._v("工作流程（证书校验 -> 非对称加密 -> 对称加密）：")]),t._v(" "),v("p",[t._v("1、客户端与服务端首先协商用什么加密算法")]),t._v(" "),v("p",[t._v("2、服务器会将自己的公钥交给数字证书认证机构，数字证书用自己的私钥对服务端的公钥进行加密，颁发"),v("strong",[t._v("数字证书认证机构颁发的公钥证书。"),v("strong",[t._v("公钥证书也可以叫")]),t._v("数字证书")]),t._v("（证书里面包含证书内容、散列算法、加密密文）")]),t._v(" "),v("p",[t._v("3、接到证书的客户端可以用数字证书认证机构的"),v("strong",[t._v("公开密钥")]),t._v("对服务端发过来证书上的数字签名进行验证。客户端通过CA机构提供的公钥（已经植入到浏览器）验证证书中的数字签名。进行解密获得散列值（数字签名），同时将证书内容使用相同的散列算法进行Hash得到另一个散列值，比对两个散列值，如果两者相等则说明证书没问题。 一旦认证通过，可以确定服务端的公开密钥是真实存在且有效的，服务器的公开密钥是值得信赖的。")]),t._v(" "),v("p",[t._v("4、然后客户端生成一个随机密码串，用验证过的"),v("strong",[t._v("服务端公开密钥")]),t._v("进行加密发给服务端，这个密码串用于加密握手信息。服务端用私钥解密拿到这个随机密码串，并也对握手信息进行加密。对比加密之后的握手信息，如果一致，则是安全的")]),t._v(" "),v("p",[t._v("5、后续HTTPS请求就用这个交换号的随机密码串进行对称加密通信")])]),t._v(" "),v("h2",{attrs:{id:"http报文"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http报文"}},[t._v("#")]),t._v(" HTTP报文")]),t._v(" "),v("p",[t._v("请求报文由请求方法、请求url、协议版本、可选的请求首部字段和内容实体构成的、报文首部由请求行（包含请求方法、请求url、学http版本）、首部字段加上其他组成")]),t._v(" "),v("p",[t._v("响应报文由协议版本、状态码、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成、响应首部由状态行（包含响应结果状态码、原因短语、和http版本）、首部字段加上其他组成")]),t._v(" "),v("h2",{attrs:{id:"http请求方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http请求方法"}},[t._v("#")]),t._v(" HTTP请求方法")]),t._v(" "),v("p",[t._v("get")]),t._v(" "),v("p",[t._v("post")]),t._v(" "),v("p",[t._v("delete")]),t._v(" "),v("p",[t._v("put")]),t._v(" "),v("p",[t._v("connect：要求用隧道协议连接代理。要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信")]),t._v(" "),v("p",[t._v("head：获得报文首部，不返回报文主体部分。用于确认url的有效性以及资源更新的日期时间等")]),t._v(" "),v("p",[t._v("options：返回支持的方法。查询针对请求url指定的资源支持的方法")]),t._v(" "),v("h2",{attrs:{id:"http首部"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http首部"}},[t._v("#")]),t._v(" HTTP首部")]),t._v(" "),v("p",[t._v("请求首部：Accept-Charset（用户代理支持的字符集以及字符集的优先顺序）、Accept-Encoding、Host（虚拟主机运行在同一个IP上，因此使用首部字段host区分，"),v("strong",[t._v("HTPP1.1中唯一必须被包含在请求内的首部字段")]),t._v("）、Range（只获取部分资源的范围请求）、User-Agent、Upgrade、If-match、if-Modified-Since、Accept（通知服务器用户代理能处理的媒体类型以及媒体类型的相对优先级）、Authorization（用户代理的认证信息）")]),t._v(" "),v("p",[t._v("响应首部：Etag资源匹配信息、Server，Location（将响应接收方引导至某个与请求url位置不同的资源）")]),t._v(" "),v("p",[t._v("实体首部：Allow（客户端能够指出的http方法）、Last-Modified、expires、Content-Type、Content-Length（实体主体部分的大小）")]),t._v(" "),v("p",[t._v("通用首部（Cache-control）")]),t._v(" "),v("h2",{attrs:{id:"http状态码"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http状态码"}},[t._v("#")]),t._v(" HTTP状态码")]),t._v(" "),v("p",[t._v("204（成功处理了请求但是没有返回任何内容no content） 206（部分内容）")]),t._v(" "),v("p",[t._v("301（永久移动，浏览器会自动跳转到新的url）302（服务器从不同网页响应请求，但请求者继续使用原来的位置临时移动）304 （未修改）307")]),t._v(" "),v("p",[t._v("400（请求报文中存在语法错误）401（认证失败）403（服务器拒绝访问）404（服务器上无法找到请求的资源）")]),t._v(" "),v("p",[t._v("502（错误网关）503（服务器暂时处于超负载或者正在停机维护）504（网关超时）")]),t._v(" "),v("h2",{attrs:{id:"http常见请求类型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http常见请求类型"}},[t._v("#")]),t._v(" HTTP常见请求类型")]),t._v(" "),v("p",[t._v("text/plain、text/html")]),t._v(" "),v("p",[t._v("application/json")]),t._v(" "),v("p",[t._v("application/x-www-form-urlencoded：将表单转为key1=value1&key2=value2的格式")]),t._v(" "),v("p",[t._v("multipart/form-data：将表单数据组织成key-value格式，用分隔符boundary处理成一条信息。既可以上传文件也可以上传参数")]),t._v(" "),v("p",[t._v("application/octet-stream :只可以上传二进制数据，通常用来上传文件")])])}),[],!1,null,null,null);_.default=s.exports}}]);
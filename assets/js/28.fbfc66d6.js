(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{440:function(v,_,t){"use strict";t.r(_);var s=t(54),a=Object(s.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"网络层"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#网络层"}},[v._v("#")]),v._v(" 网络层")]),v._v(" "),t("h2",{attrs:{id:"网络层提供的两种服务"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#网络层提供的两种服务"}},[v._v("#")]),v._v(" 网络层提供的两种服务")]),v._v(" "),t("p",[v._v("虚电路服务：可靠通信由网络保证，必须建立连接，双方靠着虚电路进行发送分组")]),v._v(" "),t("p",[v._v("数据报服务：可靠通信由用户主机保证，不需要建立连接，每个分组独立选择路由进行转发。")]),v._v(" "),t("p",[v._v("互联网采取的设计思路：网络层只向上提供简单的、无连接的、尽最大努力交付的数据报服务")]),v._v(" "),t("p",[v._v("将网络连接起来的中间设备：")]),v._v(" "),t("ul",[t("li",[v._v("物理层的转发器")]),v._v(" "),t("li",[v._v("数据链路层的网桥")]),v._v(" "),t("li",[v._v("网路层使用的路由器")]),v._v(" "),t("li",[v._v("网络层以上的使用的时网关")])]),v._v(" "),t("p",[v._v("虚拟互连网络：由于大家使用的是不同的网络，物理异构性是客观存在的，但利用IP协议就可以使性能各异的网络在网络层看起来像是一个统一的网络。")]),v._v(" "),t("h2",{attrs:{id:"ip地址"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ip地址"}},[v._v("#")]),v._v(" IP地址")]),v._v(" "),t("p",[v._v("IP地址是给互联网上的"),t("strong",[v._v("每一台主机或者路由器")]),v._v("的每一个接口分配一个"),t("strong",[v._v("在全世界范围内唯一")]),v._v("的32位标识符")]),v._v(" "),t("p",[v._v("特点：")]),v._v(" "),t("ul",[t("li",[v._v("每一个"),t("code",[v._v("IP")]),v._v("地址都是由网络号和主机号组成。IP地址管理机构在分配"),t("code",[v._v("IP")]),v._v("地址时只分配网络号，剩下的主机号由得到该网络号的单位自行分配；路由器仅根据目的主机所连接的网络号来转发分组，减小了路由表所占的存储空间和查找路由表的时间")]),v._v(" "),t("li",[v._v("路由器至少连接两个网络")]),v._v(" "),t("li",[v._v("用转发器或网桥连接起来的若干个局域网仍属于同一个网络，具有不同网络号的局域网必须通过路由器进行互连")])]),v._v(" "),t("h3",{attrs:{id:"分类的ip地址"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分类的ip地址"}},[v._v("#")]),v._v(" 分类的IP地址")]),v._v(" "),t("p",[v._v("将IP地址分为若干个固定类，由两个固定字段组成，第一个字段是网络号，它标志着主机所连接到的网络，网络号"),t("strong",[v._v("在整个互联网范围内必须唯一")]),v._v("；第二个字段是主机号，它标志该主机（或路由器），一台主机号在它"),t("strong",[v._v("前面网络号所指明的网络范围内必须是唯一的")]),v._v("。"),t("code",[v._v("IP")]),v._v("地址空间总共有"),t("code",[v._v("2^32")]),v._v("个地址")]),v._v(" "),t("p",[v._v("A类：8位网络号（0）  + 24位主机号，地址空间为"),t("code",[v._v("(2^7-2) * 2^24 = 2^31")]),v._v("，占整个IP地址空间的50%")]),v._v(" "),t("div",{staticClass:"custom-block warning"},[t("p",{staticClass:"custom-block-title"},[v._v("WARNING")]),v._v(" "),t("p",[v._v("1、可指派的网络号有126个，2的7次方减2：")]),v._v(" "),t("p",[v._v("网络号为127（01111111）保留作为本地软件的回环测试")]),v._v(" "),t("p",[v._v("网络号为00000000的是个保留地址，意思是本网络。")]),v._v(" "),t("p",[v._v("2、主机号占3个字节，最大主机数是2的24次方减2：")]),v._v(" "),t("p",[v._v("主机号全0表示所连接到的单个网络地址，例如一主机的IP地址是6.7.8.9，那么该主机连接到的网络就是6.0.0.0；主机号全1表示该网络上所有主机。")])]),v._v(" "),t("p",[v._v("B类：16位网络号（10）+ 8位主机号，占整个IP地址空间的25%")]),v._v(" "),t("p",[v._v("C类： 24位网络号 （110）+ 8位主机号，占整个IP地址空间的12.5%")]),v._v(" "),t("p",[v._v("D类： 多播地址")]),v._v(" "),t("p",[v._v("E类： 保留为今后使用")]),v._v(" "),t("p",[v._v("一般不可用的特殊IP地址：")]),v._v(" "),t("table",[t("thead",[t("tr",[t("th",[v._v("网络号")]),v._v(" "),t("th",[v._v("主机号")]),v._v(" "),t("th",[v._v("表示")])])]),v._v(" "),t("tbody",[t("tr",[t("td",[v._v("0")]),v._v(" "),t("td",[v._v("0")]),v._v(" "),t("td",[v._v("本网络的本主机")])]),v._v(" "),t("tr",[t("td",[v._v("全1")]),v._v(" "),t("td",[v._v("全1")]),v._v(" "),t("td",[v._v("只在本网络上进行广播")])]),v._v(" "),t("tr",[t("td",[v._v("net-id")]),v._v(" "),t("td",[v._v("全1")]),v._v(" "),t("td",[v._v("对net-id上的所有主机进行广播")])]),v._v(" "),t("tr",[t("td",[v._v("127")]),v._v(" "),t("td",[v._v("非全0或全1的任何数")]),v._v(" "),t("td",[v._v("用于本地软件的回环测试")])])])]),v._v(" "),t("h3",{attrs:{id:"ip地址和硬件地址"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ip地址和硬件地址"}},[v._v("#")]),v._v(" IP地址和硬件地址")]),v._v(" "),t("p",[v._v("物理地址是数据链路层和物理层用的地址，IP地址是网络层及以上用的地址，是逻辑地址")]),v._v(" "),t("p",[v._v("MAC帧传送时使用的源地址和目的地址都是硬件地址，写在首部中，接收方收到MAC帧后，根据首部的硬件地址决定收下或者丢弃。剥去MAC帧首部和尾部后，才将数据上交到网络层，网络层才能在IP数据报中找到源IP地址和目标IP地址")]),v._v(" "),t("p",[v._v("IP层抽象的互联网中只能看到IP数据报，数据报中间经过的路由器IP地址并不出现在IP数据报的首部中。")]),v._v(" "),t("p",[v._v("在局域网的链路层，只能看见MAC帧。在不同网络中传送时，MAC帧首部中的源地址和目的地址要发生变化。")]),v._v(" "),t("p",[v._v("尽管互连在一起的网络的硬件地址体系各不相同，但IP层抽象的互联网却屏蔽了下层很复杂的细节，只要在网络层讨论问题，就能够使用统一的、抽象的IP地址进行通信")]),v._v(" "),t("h3",{attrs:{id:"地址解析协议arp"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#地址解析协议arp"}},[v._v("#")]),v._v(" 地址解析协议ARP")]),v._v(" "),t("p",[v._v("知道了IP地址，需要找出其对应的硬件地址，ARP就是来解决这个问题的，为了从网络层使用的IP地址解析出在数据链路层的硬件地址")]),v._v(" "),t("p",[v._v("IP地址32位，局域网硬件地址48位，并且网络中的主机也会不停变化，所以ARP在主机ARP高速缓存中存放一个IP地址道硬件地址的"),t("strong",[v._v("映射表")]),v._v("，并且这个映射表会"),t("strong",[v._v("动态更新")])]),v._v(" "),t("p",[v._v("过程：")]),v._v(" "),t("p",[v._v("当主机A要向局域网中主机B发送IP数据报时，先在ARP高速缓存中查看有无主机B的IP地址，如果有，就找到了对应的硬件地址，再把硬件地址写入MAC帧；如查不到：")]),v._v(" "),t("p",[v._v("（1）ARP进程在本地局域网广播发送一个ARP请求分组，请求中带有A的IP地址、A的硬件地址，以及要查找的IP地址")]),v._v(" "),t("p",[v._v("（2）在本局域网所有主机上运行的ARP进程都能收到此ARP请求分组")]),v._v(" "),t("p",[v._v("（3）主机B的IP地址与ARP请求分组中要查询的IP地址一致，就发送ARP响应分组，同时在响应分组中加上自己的硬件地址。并且"),t("strong",[v._v("同时会将A请求ARP分组中A的IP地址到硬件地址的映射写入到自己的高速缓存中，方便下次发送")]),v._v("，其余所有主机都和IP地址不匹配，就不会理会这个请求了")]),v._v(" "),t("p",[v._v("（4）A收到响应分组后就将其写入自己的ARP高速缓存中")]),v._v(" "),t("details",{staticClass:"custom-block details"},[t("summary",[v._v("DETAILS")]),v._v(" "),t("p",[v._v("（1）ARP高速缓存会设置一个超时时间")]),v._v(" "),t("p",[v._v("（2）ARP地址协议时是解决"),t("strong",[v._v("同一个局域网上")]),v._v("的主机或路由器的IP地址和硬件地址的映射问题的。无法解析出另一个局域网上的主机的硬件地址")]),v._v(" "),t("p",[v._v("（3）不同的网络使用不同的硬件地址，IP地址的使用避免了硬件地址的复杂转化。ARP将IP映射到硬件地址，"),t("strong",[v._v("用户对这种地址解析过程是不知道的")])])]),v._v(" "),t("div",{staticClass:"custom-block warning"},[t("p",{staticClass:"custom-block-title"},[v._v("WARNING")]),v._v(" "),t("p",[v._v("路由器也能广播ARP分组")])]),v._v(" "),t("p",[v._v("IP地址是使不同网络中、不同硬件地址的主机之间通信变得方便，不同的硬件地址直接转换是很麻烦的。")]),v._v(" "),t("h3",{attrs:{id:"ip数据报格式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ip数据报格式"}},[v._v("#")]),v._v(" IP数据报格式")]),v._v(" "),t("p",[v._v("首部"),t("strong",[v._v("固定长度")]),v._v("20个字节，后面还有"),t("strong",[v._v("首部可选长度")]),v._v("和"),t("strong",[v._v("数据部分")])]),v._v(" "),t("p",[v._v("（1）版本：IP协议的版本，4位")]),v._v(" "),t("p",[v._v("（2）首部长度：占4位，1个单位是4个字节，所有首部长度最小为5（该字段为0101），即20个字节固定长度，规定最大为15，即60个字节。")]),v._v(" "),t("p",[v._v("（3）区分服务：占8位，一般情况不使用这个字段")]),v._v(" "),t("p",[v._v("（4）总长度：指首部和数据之和的长度，2个字节，16位，数据报最大长度2^16 -1。在IP层下面的每一种数据链路层协议都规定了数据帧的数据字段最大长度，称为最大传送单元MTU，IP数据报的总长度（首部+IP的数据）一定不能超过下面链路层规定的MTU值。以太网的MTU为1500个字节。")]),v._v(" "),t("p",[v._v("（5）标识：16位，每产生一个数据报，计数器加1，将此值赋给标识字段。分片后的数据报使用相同的标识，方便最终能正确的重装")]),v._v(" "),t("p",[v._v("（6）标志：3位，目前只有两位有意义，最低位MF，标识后面还有分片，中间一位DF，标识不能分片，只有DF=0才允许分片")]),v._v(" "),t("p",[v._v("（7）片偏移：13位，较长的分组在分片后，某片在原分组中的相对位置")]),v._v(" "),t("p",[v._v("（8）生存时间：占8位，TTL，数据报在网络中的寿命。目前TTL的功能改为跳数限制，每次"),t("strong",[v._v("转发数据报之前")]),v._v("（TTL为1不能被路由器转发）就把TTL减1，若减到0，就丢弃这个数据报，TTL的意义是数据报在互联网中至多可经过多少个路由器")]),v._v(" "),t("p",[v._v("（9）协议：上层的协议")]),v._v(" "),t("p",[v._v("（10）首部检验和：16位，这个字段只校验数据报的首部，不包括数据部分。因为要将IP数据报首部划分为很多个16位字去相加，所以是检验和也为16位长。")]),v._v(" "),t("p",[v._v("（11）源地址：32位，4个字节")]),v._v(" "),t("p",[v._v("（12）目的地址：32位，4个字节")]),v._v(" "),t("h3",{attrs:{id:"ip分组转发的流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ip分组转发的流程"}},[v._v("#")]),v._v(" IP分组转发的流程")]),v._v(" "),t("p",[v._v("一个路由器上指出到某个网络应如何转发，收到的目的主机IP地址，应该将其网络号进行匹对，查询路由表中有没有要到达的目的网络号。每一个路由最主要的信息："),t("strong",[v._v("（目的网络地址，下一跳地址）")]),v._v("。在从路由表中得到下一跳IP地址后，"),t("strong",[v._v("不是")]),v._v("把该地址填入IP数据报，而是送交数据链路层的网络接口软件，网络接口软件负责把"),t("strong",[v._v("下一跳IP地址转换为硬件地址（用ARP）")]),v._v("，并将此硬件地址放在数据链路层的MAC帧首部，然后就可以进行下一跳了。")]),v._v(" "),t("p",[v._v("分组转发算法：")]),v._v(" "),t("p",[v._v("（1）从数据报首部提取出目的主机IP地址D，目的网络地址N；")]),v._v(" "),t("p",[v._v("（2）若N是此路由器直接相连的某个网络地址，则直接交付，在这个网络中查找该主机交付，D映射为硬件地址交付；否则就是间接交付")]),v._v(" "),t("p",[v._v("（3）路由表中有目的地址D的特定主机路由，则跳到这个路由")]),v._v(" "),t("p",[v._v("（4）路由表中有到达N的路由（即路由表中记录了有一个路由的IP），则把数据报传送给指明的路由")]),v._v(" "),t("h2",{attrs:{id:"划分子网"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#划分子网"}},[v._v("#")]),v._v(" 划分子网")]),v._v(" "),t("p",[v._v("考虑到：")]),v._v(" "),t("p",[v._v("（1）IP地址的利用率有时很低。申请到的网络连接的主机并不多。")]),v._v(" "),t("p",[v._v("（2）给每一个物理网络分配一个网络，会造成路由表变得太大而使网络性能变坏。")]),v._v(" "),t("p",[v._v("（3）两级IP地址不够灵活。当一个单位马上要新开一个网络，需要去申请。")]),v._v(" "),t("p",[v._v("基本思路：")]),v._v(" "),t("p",[v._v("（1）一个单位将所属物理网络划分为若干个子网，对外仍然表现为一个网络。")]),v._v(" "),t("p",[v._v("（2）两级IP地址在本单位内部变成三级IP地址：（网络号、（子网号、主机号）），"),t("strong",[v._v("从主机号中借用若干位作为子网号")]),v._v("。")]),v._v(" "),t("p",[v._v("（3）路由器收到IP数据报后，再按目的网络号和子网号找到目的子网，把IP数据报交付主机")]),v._v(" "),t("h3",{attrs:{id:"子网掩码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#子网掩码"}},[v._v("#")]),v._v(" 子网掩码")]),v._v(" "),t("p",[v._v("145.13.3.10到达路由器，路由器要怎么转发到子网145.13.3.0？这就利用了子网掩码。")]),v._v(" "),t("div",{staticClass:"custom-block warning"},[t("p",{staticClass:"custom-block-title"},[v._v("WARNING")]),v._v(" "),t("p",[v._v("从IP数据报的首部无法看出源主机或目的主机所连接的网络是否进行了子网划分")])]),v._v(" "),t("p",[v._v("子网掩码也是32位，对B类地址，若借用8位主机号作为子网号，则三级IP地址的子网掩码由24位1，8位0组成，因为B类地址前16位是网络号，后16位是主机号，而划分子网会将主机号中的8位借用为子网号。")]),v._v(" "),t("p",[v._v("将子网掩码和目的IP地址作按位与运算，即能得到子网的网络地址145.13.0")]),v._v(" "),t("p",[v._v("路由器的路由表必须有子网掩码这一栏，如果一个网络不划分子网，那么其"),t("strong",[v._v("子网掩码中的1和IP地址中的网络号")]),v._v("相对应。那么用子网掩码和该IP地址作按位与运算就能得到目的网络地址。")]),v._v(" "),t("p",[v._v("A类地址的默认子网掩码是255.0.0.0")]),v._v(" "),t("p",[v._v("B类地址的默认子网掩码是255.255.0.0")]),v._v(" "),t("p",[v._v("C类地址的默认子网掩码是255.255.255.0")]),v._v(" "),t("p",[v._v("划分子网选择可以多样，子网位数为n，那么除去全0和全1，可用的子网数就是"),t("code",[v._v("2^n-2")]),v._v(";若使用较少的子网位数，则可以使用的主机就多。")]),v._v(" "),t("h3",{attrs:{id:"路由转发的改变"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#路由转发的改变"}},[v._v("#")]),v._v(" 路由转发的改变")]),v._v(" "),t("p",[v._v("当划分了子网后，路由器必须包含以下三项内容：目的网络地址，子网掩码，下一跳地址")]),v._v(" "),t("p",[v._v("（1）从数据报首部提取出目的主机IP地址D；")]),v._v(" "),t("p",[v._v("（2）对路由器直接相连的网络进行检查，用相连的网络的子网掩码和D作按位与运算，看是否和相应的网络地址匹配，若匹配，则直接交付")]),v._v(" "),t("p",[v._v("（3）路由表中有目的地址D的特定主机路由，则跳到这个路由")]),v._v(" "),t("p",[v._v("（4）对路由表中的每一行进行查询，子网掩码和D作按位与运算")]),v._v(" "),t("h2",{attrs:{id:"构造超网-无分类编址cidr"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#构造超网-无分类编址cidr"}},[v._v("#")]),v._v(" 构造超网（无分类编址CIDR）")]),v._v(" "),t("p",[v._v("由于IP的地址很快就会分配完，加之路由表中的项目急剧增长。CIDR可以解决IP地址的利用率")]),v._v(" "),t("p",[v._v("CIDR：无分类域间路由选择")]),v._v(" "),t("p",[v._v("特点：")]),v._v(" "),t("p",[v._v("（1）消除了传统的A类、B类、C类以及划分子网的概念；将IP的地址分为两部分，一部分是网络前缀，另一部分是主机号；把IP地址从上述三级划分又变为两级划分：IP地址={网络前缀， 主机号}，CIDR采用斜线记法，"),t("strong",[v._v("即在IP地址后面加上斜线，写上网路前缀所占的位数")])]),v._v(" "),t("p",[v._v("（2）把网络前缀相同的连续IP地址组成了一个CIDR地址块：可以很方便得连续IP地址的起始地址和最大地址。IP地址是128.14.35.7/20的最小地址是10000000|00001110|0010|"),t("strong",[v._v("0000 00000000 ，最大地址是")]),v._v("10000000|00001110|0010|"),t("strong",[v._v("1111 11111111")]),v._v("，这个地址包含"),t("code",[v._v("2^12")]),v._v("个地址")]),v._v(" "),t("div",{staticClass:"custom-block warning"},[t("p",{staticClass:"custom-block-title"},[v._v("WARNING")]),v._v(" "),t("p",[t("strong",[v._v("CIDR中的子网掩码中1的位数等于网络前缀的位数")]),v._v("，如上面的CIDR斜线记法则子网掩码中1的位数为20位。")])]),v._v(" "),t("p",[v._v("一个CIDR地址块有很多IP地址，所以在路由器中就利用CIDR地址块来查找目的网络。这种地址的聚合也叫做"),t("strong",[v._v("路由聚合")]),v._v("，也称为"),t("strong",[v._v("构成超网")]),v._v("。")]),v._v(" "),t("p",[v._v("网络前缀一般在13~27位之间；18位网络前缀，/18，点分十进制255.255.192.0，18个1，所包含的IP地址数"),t("code",[v._v("2^14")]),v._v("，就包含了64个C类/24网络，就有64 * "),t("code",[v._v("2^8")]),v._v("个IP地址")]),v._v(" "),t("h3",{attrs:{id:"最长前缀匹配"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#最长前缀匹配"}},[v._v("#")]),v._v(" 最长前缀匹配")]),v._v(" "),t("p",[v._v("IP地址由网路前缀和主机号构成，所以相应的路由项也改变为“网络前缀”和“下一跳地址”。")]),v._v(" "),t("p",[v._v("提取目的地址D，将D和路由表中的每一项网络前缀（可以理解为跳往的下一个路由器的网络前缀）相与，看是否和目的地址的网络前缀相匹配，这时有可能有多个匹配，规定要匹配网络前缀更长的路由")]),v._v(" "),t("p",[v._v("例如：D=206.0.71.130，而下一跳的网络前缀有206.0.68.0/22，206.0.71.128/25，D和这两个前缀想与都能匹配的上，但是选择25为前缀的那个网络。")]),v._v(" "),t("h3",{attrs:{id:"二叉树查找路由表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二叉树查找路由表"}},[v._v("#")]),v._v(" 二叉树查找路由表")]),v._v(" "),t("p",[v._v("减小路由匹配的时间")]),v._v(" "),t("p",[v._v("将路由表中的IP地址构成一颗二叉树，二叉树的搜索路径就构成了路由表中存放的地址。搜索到一个结点时，将目的地址和该叶子结点的子网掩码进行逐位与运算，看是否和对应的网络前缀匹配。")]),v._v(" "),t("h2",{attrs:{id:"网际控制报文协议icmp"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#网际控制报文协议icmp"}},[v._v("#")]),v._v(" 网际控制报文协议ICMP")]),v._v(" "),t("p",[v._v("为了更有效的转发IP数据报和提高交付成功的机会，在网际层使用了网际控制报文协议ICMP。允许"),t("strong",[v._v("主机或路由器报告差错情况和提供有关异常情况的报告")]),v._v("。"),t("strong",[v._v("ICMP报文是装在IP数据报中，作为其数据部分的")]),v._v("。ICMP报文作为IP数据报的数据，加上IP的首部，组成IP数据报发送出去。")]),v._v(" "),t("p",[v._v("ICMP报文的种类分为ICMP差错报文和ICMP询问报文")]),v._v(" "),t("p",[v._v("ICMP报文前4个字节是统一格式，共有三个字段：类型（8位）、代码（8位）、检验和（16位），接着的4个字节的内容与ICMP的类型有关，最后面是数据字段，其长度取决于ICMP的类型。ICMP报文内容即：4 + 4 + ICMP的数据")]),v._v(" "),t("p",[v._v("检验和字段检验整个ICMP报文，相比IP数据报的检验和，不检验IP数据报的数据部分。")]),v._v(" "),t("p",[v._v("ICMP差错报文的组成：把收到的需要进行差错报告的IP数据报的首部和数据字段的前8字节提取出来，作为ICMP报文的数据字段，再加上ICMP报文的"),t("strong",[v._v("前8字节")]),v._v("。整个ICMP报文作为IP数据报的数据字段发送给源点。")]),v._v(" "),t("h3",{attrs:{id:"icmp的应用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#icmp的应用"}},[v._v("#")]),v._v(" ICMP的应用")]),v._v(" "),t("p",[t("code",[v._v("PING")]),v._v("：测试两台主机之间的连通性。PING使用ICMP回送请求和回送回答报文。")]),v._v(" "),t("p",[t("code",[v._v("Traceroute")]),v._v("：从源主机向目的主机发送一连串的IP数据报，数据报中封装的是无法交付的UDP数据报。用这个指令可以得出源主机到目的主机所经过的路由器IP地址。")]),v._v(" "),t("h2",{attrs:{id:"路由选择协议"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#路由选择协议"}},[v._v("#")]),v._v(" 路由选择协议")]),v._v(" "),t("p",[v._v("核心是路由算法。")]),v._v(" "),t("p",[v._v("互联网采用的路由选择协议是自适应的、分布式路由选择协议。")]),v._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),t("p",[v._v("从路由算法是否能随网络的通信量或拓扑自适应的进行调整来划分，可以分为静态路由选择和动态路由选择")])]),v._v(" "),t("p",[v._v("将整个互联网分为许多较小的自治系统，记为AS。自治系统AS对其他AS表现出的是一个单一的和一致的路由策略")]),v._v(" "),t("p",[v._v("互联网把路由选择协议分为两大类：内部网关协议IGP和外部网关协议EGP。")]),v._v(" "),t("p",[v._v("自治系统之间的路由选择叫做域间路由选择，自治系统内部的路由选择叫做域内路由选择。每个自治系统自己决定在本自治系统内部运行哪一个内部路由选择协议（RIP、OSRF），每个自治系统都有一个或多个路由器，运行着系统间的路由选择协议（BGP-4）。")]),v._v(" "),t("h3",{attrs:{id:"内部网关协议rip"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#内部网关协议rip"}},[v._v("#")]),v._v(" 内部网关协议RIP")]),v._v(" "),t("p",[v._v("RIP是一种"),t("strong",[v._v("分布式")]),v._v("的基于"),t("strong",[v._v("距离向量")]),v._v("的路由选择协议。要求网络中的每个路由器都维护一个从自己到其他每一个目的网络的距离标记。")]),v._v(" "),t("p",[v._v("距离定义如下：从一路由器到直接连接的网络距离为1，从一路由器到非直接连接的网络距离为所经过的路由器加1。")]),v._v(" "),t("p",[v._v("RIP的距离也称为跳数，每经过一个路由器，跳数就加1。允许一条路径只能包含15个路由器，距离等于16相当于不可达。RIP只适用于小型互联网。")]),v._v(" "),t("details",{staticClass:"custom-block details"},[t("summary",[v._v("Q&A")]),v._v(" "),t("p",[v._v("Q：和哪些路由器交换信息？")]),v._v(" "),t("p",[v._v("A：仅和"),t("strong",[v._v("相邻路由器")]),v._v("交换信息。"),t("strong",[v._v("如果两个路由器之间的通信不需要经过另一个路由器，那么这两个路由器就是相连的")])]),v._v(" "),t("p",[v._v("Q：交换什么信息？")]),v._v(" "),t("p",[v._v("A：交换的是当前路由器所知道的"),t("strong",[v._v("全部信息")]),v._v("，即自己现在的路由表。")]),v._v(" "),t("p",[v._v("Q：在什么时候交换信息？")]),v._v(" "),t("p",[v._v("A：按"),t("strong",[v._v("固定时间间隔30s")]),v._v("交换路由信息。")])]),v._v(" "),t("p",[v._v("路由器在刚刚开始工作时，路由表是空的，然后路由表得出直接相连的几个网络的距离，都为1，然后每一个路由器只和数目非常有限的相邻路由器进行交换，经过若干次更新后，一个路由器就有知道到达"),t("strong",[v._v("本自治系统内任何一个网络的最短距离和下一跳的路由器地址")]),v._v("了。")]),v._v(" "),t("p",[v._v("路由表中最重要的信息是：到某个网络的最短距离以及应经过的下一跳地址。路由表更新的原则是找出每个目的网络的最短距离。更新算法叫距离向量算法。")]),v._v(" "),t("h4",{attrs:{id:"距离向量算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#距离向量算法"}},[v._v("#")]),v._v(" 距离向量算法")]),v._v(" "),t("p",[v._v("对每一个相邻路由器发送过来的RIP报文进行以下处理：")]),v._v(" "),t("p",[v._v("（1）对地址"),t("code",[v._v("X")]),v._v("的相邻路由器发来的RIP报文，"),t("strong",[v._v("先修改此报文中的所有项目，把下一跳地址都改为X，并把距离加1")]),v._v("，即目的网络"),t("code",[v._v("N")]),v._v("，下一跳路由器为"),t("code",[v._v("X")]),v._v("，距离是"),t("code",[v._v("d")]),v._v("。")]),v._v(" "),t("p",[v._v("（2）若原来路由表没有网络"),t("code",[v._v("N")]),v._v("，则新增；若有网络N，并且下一跳地址是X，则更新；若有网络N，但下一跳地址不是X，则需要进行距离比较。")]),v._v(" "),t("p",[v._v("对于RIP报文如“Net2，3，Y”表示"),t("strong",[v._v("位于X的相邻路由，经过路由器Y到网络2的距离为3")]),v._v("，那么本路由器可以推断出：经过X到网络2的距离为3+1，于是将本路由器收到的RIP报文改为“Net2，4，X”，作为下一步和路由表中原有项比较时使用")]),v._v(" "),t("p",[v._v("如果路由表中没有到达网络2的项，则新增")]),v._v(" "),t("p",[v._v("如果有到达网络2的，且下一跳路由器地址也是X，那么要更新，以最新的为主")]),v._v(" "),t("p",[v._v("如果有到达网络2的，且下一跳路由器地址不是X，那么就要比较了，得出距离较短的下一跳路由器。")]),v._v(" "),t("h3",{attrs:{id:"内部网关协议-osrf"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#内部网关协议-osrf"}},[v._v("#")]),v._v(" 内部网关协议 OSRF")]),v._v(" "),t("p",[v._v("RIP因为路径长度最多到16，所以只适合规模小的网络中；而OSRF适用于规模较大的网络。")]),v._v(" "),t("p",[t("code",[v._v("OSRF")]),v._v("：开放最短路径优先，使用了Dijkstra提出的最短路径算法，使用"),t("strong",[v._v("分布式")]),v._v("的"),t("strong",[v._v("链路状态")]),v._v("协议，而不是RIP的距离向量协议。")]),v._v(" "),t("p",[v._v("与"),t("code",[v._v("RIP")]),v._v("的区别如下：")]),v._v(" "),t("p",[v._v("（1）用洪泛法进行发送信息，一个路由器给相邻路由发送信息后，每一个相邻路由器又将此信息发送给其所有相邻路由器，这样域内所有路由器都会得到信息的一个副本。相比"),t("code",[v._v("RIP")]),v._v("，只是向其相邻的路由器发送信息")]),v._v(" "),t("p",[v._v("（2）发送的信息就是与本路由器相邻的所有路由器的"),t("strong",[v._v("链路状态")]),v._v("。“链路状态”指的是本路由器和哪些路由器相邻，以及到达某相邻路由器的“代价”。相比"),t("code",[v._v("RIP")]),v._v("，发送的路由信息是到达某网络的距离和下一跳路由")]),v._v(" "),t("p",[v._v("（3）只有当链路状态发生变化时，路由器才向所有路由器用洪泛法发送此信息。相比RIP，需要定期交换信息。")]),v._v(" "),t("p",[v._v("使用了"),t("code",[v._v("OSRF")]),v._v("协议的路由器可以知道全网的路由器链路状态，可以建立一个"),t("strong",[v._v("链路状态数据库")]),v._v("，构造出自己的路由表，"),t("code",[v._v("RIP")]),v._v("协议只知道到所有网络的距离以及下一跳路由，并不知道全网的拓扑结构。")]),v._v(" "),t("p",[v._v("为了使OSRF能用于规模很大的网络，OSRF将一个自治系统再划分位若干个更小的区，让洪泛法只在区中进行，一个区中的路由器并不知道另一个区的网络拓扑结构。")]),v._v(" "),t("p",[v._v("规定主干区域的区域标识符为0.0.0.0，作用是连通其他在下一层的区域。从其他区域来的信息都是由"),t("strong",[v._v("区域边界路由器")]),v._v("进行概括，每一个区域都要有一个"),t("strong",[v._v("区域边界路由器")]),v._v("。")]),v._v(" "),t("p",[v._v("OSRF不用UDP而是"),t("strong",[v._v("直接使用IP数据报")]),v._v("进行传送,，RIP协议是使用UDP的。")]),v._v(" "),t("p",[v._v("OSRF有5种分组类型：问候分组、数据库描述分组、链路状态请求、链路状态更新、链路状态确认。后面4种一般用于同步数据库")]),v._v(" "),t("p",[v._v("OSRF协议规定每隔10s就要交换一次问候分组，确定"),t("strong",[v._v("邻站是否可达")]),v._v("。数据库描述分组用于和相邻路由器交换本数据库中已有的链路状态摘要信息。")]),v._v(" "),t("p",[v._v("在网络运行过程中，只要一个路由器的链路状态发生变化，该路由器更新分组，用洪泛法向全网更新链路状态。")]),v._v(" "),t("p",[v._v("OSRF使用的是可靠的洪泛法，在收到更新分组后要发送确认。")]),v._v(" "),t("h3",{attrs:{id:"路由器的构成"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#路由器的构成"}},[v._v("#")]),v._v(" 路由器的构成")]),v._v(" "),t("p",[v._v("路由器是一种具有多个输入端口和多个输出端口的专用计算机，其任务是转发分组，可划分为路由选择部分和分组转发部分。")]),v._v(" "),t("p",[v._v("分组转发部分由交换结构、一组输入端口、一组输出端口。交换结构的作用是根据转发表对分组进行处理，将输入端口进入的分组从一个合适的输出端口转发出去。")]),v._v(" "),t("div",{staticClass:"custom-block warning"},[t("p",{staticClass:"custom-block-title"},[v._v("WARNING")]),v._v(" "),t("p",[v._v("转发仅仅涉及到一个路由器，路由选择涉及到很多路由器，路由表则是许多路由器协同工作的结果")])]),v._v(" "),t("p",[v._v("分组转发是通过转发表，转发表是通过路由表得来，两者用不同数据结构实现会带来一些好处，在讨论路由选择原理的时候，不去区分这两者的区别。")]),v._v(" "),t("p",[v._v("分组在路由器的输入输出端口处都可能会在队列中排队等候处理。若分组处理的速率赶不上分组进入队列的速率，则队列的存储空间最终必定减少，这就使后来的分组由于没有存储空间而只能被丢弃")]),v._v(" "),t("p",[v._v("交换结构：")]),v._v(" "),t("p",[v._v("1、利用计算机的CPU作为路由选择处理机，当路由器一个输入端口接收到分组，利用中断方式告诉处理机，处理机拿到分组到存储器，处理机从分组首部提取目的地址，查找路由表，将分组复制到合适的输出端口中。")]),v._v(" "),t("p",[v._v("2、总线形式：通过共享总线直接传送到合适的输出端口，不需要路由选择处理机干预。但同一时间只能有一个分组在总线上传输")]),v._v(" "),t("p",[v._v("3、互连网络形式：有N个输入端口就有2N条总线，横纵交叉。输入输出端口确定后，只有水平垂直方向相对应总线空闲，才能转发成功")])])}),[],!1,null,null,null);_.default=a.exports}}]);